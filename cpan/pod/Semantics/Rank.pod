# Copyright 2022 Jeffrey Kegler
# This file is part of Marpa::R2.  Marpa::R2 is free software: you can
# redistribute it and/or modify it under the terms of the GNU Lesser
# General Public License as published by the Free Software Foundation,
# either version 3 of the License, or (at your option) any later version.
#
# Marpa::R2 is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser
# General Public License along with Marpa::R2.  If not, see
# http://www.gnu.org/licenses/.

=head1 NAME

Marpa::R2::Semantics::Rank - How ranks are computed

=head1 Synopsis

=for Marpa::R2::Display
name: Rank document synopsis
normalize-whitespace: 1

    my $source = <<'END_OF_SOURCE';
      :discard ~ ws; ws ~ [\s]+
      :default ::= action => ::array

      Top ::= List action => main::group
      List ::= Item3 rank => 3
      List ::= Item2 rank => 2
      List ::= Item1 rank => 1
      List ::= List Item3 rank => 3
      List ::= List Item2 rank => 2
      List ::= List Item1 rank => 1
      Item3 ::= VAR '=' VAR action => main::concat
      Item2 ::= VAR '='     action => main::concat
      Item1 ::= VAR         action => main::concat
      VAR ~ [\w]+

    END_OF_SOURCE

    my @tests = (
        [ 'a',                 '(a)', ],
        [ 'a = b',             '(a=b)', ],
        [ 'a = b = c',         '(a=)(b=c)', ],
        [ 'a = b = c = d',     '(a=)(b=)(c=d)', ],
        [ 'a = b c = d',       '(a=b)(c=d)' ],
        [ 'a = b c = d e =',   '(a=b)(c=d)(e=)' ],
        [ 'a = b c = d e',     '(a=b)(c=d)(e)' ],
        [ 'a = b c = d e = f', '(a=b)(c=d)(e=f)' ],
    );

    my $grammar = Marpa::R2::Scanless::G->new( { source => \$source } );
    for my $test (@tests) {
        my ( $input, $output ) = @{$test};
        my $recce = Marpa::R2::Scanless::R->new(
            {
                grammar        => $grammar,
                ranking_method => 'high_rule_only'
            }
        );
        $recce->read( \$input );
        my $value_ref = $recce->value();
        if ( not defined $value_ref ) {
            die 'No parse';
        }
        push @results, ${$value_ref};
    }

=for Marpa::R2::Display::End

=for Marpa::R2::Display
name: rank example semantics
normalize-whitespace: 1

    sub flatten {
        my ($array) = @_;

        # say STDERR 'flatten arg: ', Data::Dumper::Dumper($array);
        my $ref = ref $array;
        return [$array] if $ref ne 'ARRAY';
        my @flat = ();
      ELEMENT: for my $element ( @{$array} ) {
            my $ref = ref $element;
            if ( $ref ne 'ARRAY' ) {
                push @flat, $element;
                next ELEMENT;
            }
            my $flat_piece = flatten($element);
            push @flat, @{$flat_piece};
        }
        return \@flat;
    }

    sub concat {
        my ( $pp, @args ) = @_;

        # say STDERR 'concat: ', Data::Dumper::Dumper(\@args);
        my $flat = flatten( \@args );
        return join '', @{$flat};
    }

    sub group {
        my ( $pp, @args ) = @_;

        # say STDERR 'comma_sep args: ', Data::Dumper::Dumper(\@args);
        my $flat = flatten( \@args );
        return join '', map { +'(' . $_ . ')'; } @{$flat};
    }

=for Marpa::R2::Display::End

=head1 Description

This document describes rule ranking.
Rule ranking plays a role in parse ordering,
which is described in L<a separate
document|Marpa::R2::Semantics::Order>.

=head1 Ranking methods

SLIF recognizer objects have a L<C<ranking_method> named
argument|Marpa::R2::Scanless::R/"ranking_method">,
whose value can be the name of a ranking method,
or "C<none>", indicating that the default ranking method is to
be used.

=head2 The C<rule> ranking method

The C<rule> ranking method ranks alternative parses according to their rule alternatives.
Every rule alternative has a B<numeric rank>.
A rule's rank can be specified using the
the C<rank> adverb
argument for that RHS alternative.
Rule ranks must be integers.
They may be negative.
If no numeric rank is specified, the numeric rank is 0.

=head2 The C<high_rule_only> ranking method

The C<high_rule_only> ranking method is similar to the
C<rule> ranking method, except that, at every choicepoint,
it discards all of the choices which
have a rank lower than that of the highest ranked choice.

The C<high_rule_only> ranking method
can reduce the ambiguity of a parse,
but it does not necessarily do so.
This is because, at each choicepoint among the parse trees,
it is possible that several of the choices,
or all of them, will have the same rank
as the highest ranked choice.

=head1 Rule ranking

At each choicepoint,
the choices
are ranked as follows:

=over

=item * B<Different numeric ranks>:

If the two parse choices have different numeric ranks,
they must also have different rule alternatives.
The parse choice whose rule alternative has the higher numeric rank
will rank high.

=item * B<Same rule alternative>:

If the two parse choices have the same rule alternative,
they rank as described
under L<"Null variant ranking">.

=item * B<Same numeric rank, different rule alternatives>:

Two different rule alternatives can have the same numeric rank.
If the two parse choices are for
rule alternatives that are different,
but that have the same numeric rank,
the relative order of the two parse choices is
arbitrary.

=back

Rule alternatives may be part of a single rule in the DSL --
for example, a
L<prioritized rule|Marpa::R2::Scanless::DSL/"Prioritized rule">.
Lexical order within a DSL rule
makes no difference when ranking rule alternatives.
For example, it makes no difference if two rule alternatives
come from the same prioritized rule;
or from two different prioritized rules.

=head1 Null variant ranking

Some rules have a RHS which contains
B<proper nullables>:
symbols
which may be nulled, but which are not nulling
symbols.
(Nulling symbols are symbols which are B<always> nulled.)

When a rule alternative contains proper nullables,
each instance
of that rule creates a B<nulling variant>.
A B<nulling variant> is
a specific pattern of
null and non-null symbols in a rule instance's RHS.
In many cases, this creates an ambiguity -- different
nulling variants can match the same substring in the input.
In ambiguous parsings of this kind,
some applications may want to rank nulling variants that start
with non-null symbols higher.
Other applications may want to do the opposite --
to rank nulling variants that start
with null symbols higher.

The
L<C<null-ranking> adverb
for RHS alternatives|Marpa::R2::Scanless::DSL/"null-ranking">
specifies which nulling variants are ranked high or low.
If the C<null-ranking> is "C<low>",
then the closer a nulling variant
places its B<visible> (non-null) symbols to the start of the rule instance,
the higher it ranks.
A null ranking of C<low> is the default.
If the C<null-ranking> is "C<high>",
then the closer a nulling variant
places its B<null> symbols to the start of the rule instance,
the higher it ranks.
In ranking nulling variants with more than one proper nullable,
major-to-minor is left-to-right.

=head1 Choicepoints

When ranking, the logic traverses each node
of a parse forest, which we call a "bocage".
Our parse forests closely
resemble
Elizabeth Scott's SPPF's.
See L<Marpa::R2::Advanced::Bibliography/"Scott 2008">.

Ranking is done at B<choicepoints>.
These are the or-nodes of the bocage.
They closely resemble the or-nodes of traditional parse forests.

An or-node is similar to
an Earley item with confluences:
it has a dotted rule, an origin,
a current location, and
a set of confluences.
For more about Earley items and confluences,
see L<our document on the Marpa
algorithm|Marpa::R2::Algorithm>.

Predictions and the start Earley item are redundant information
from the point of of the bocage,
and no or-nodes are created for them.
Therefore choicepoints exist only for scanned Earley items and reductions.

Every confluence linked to an Earley item is called a "choice".
Since choicepoints are always either scanned Earley items or
reductions,
they always have a well-defined mainstem
and a well-defined tributary.

A confluence is a reason for the choicepoint to be in the parse
forest.
Every choicepoint has at least one reason to be
in the parse forest, or it would not be there.
Therefore every Earley item has at least one confluence.
In an ambiguous parse, one or more Earley items will
have more than one confluence.
A parse tree is created by selecting a single
confluence (or reason to exist) for each or-node.

Since every choicepoint has exactly one dotted rule,
exactly one current location,
and exactly one origin,
a choicepoint has exactly one mainstem.
All the choices for that choicepoint share that mainstem.
Because every choicepoint
has a single mainstem
and is either a scanned Earley item or a reduction,
every choicepoint has exactly one predot symbol.

Ranks are assigned based on the symbolic differences of choices.
As we have just seen, every choice has the same mainstem,
so ranks must be assigned to choices based on
symbolic differences in their tributaries.

A tributary of a scanned choicepoint has only one symbol --
the token symbol.
The token symbol must also be the predot symbol of the choicepoint.
We have seen that there is exactly one predot symbol for every choicepoint,
so the token symbols of the choices of a scanned choicepoint must
all be the same.
This implies that the choices of a scanned choicepoint will all have
the same rank.

If a choicepoint is a reduction,
the tributaries of its choices
will be completions,
and each tributary have a rule associated with it.
The LHS of the rule for each choice in a choicepoint
will be the predot symbol of the choicepoint.
This means that the rules of the tributaries of choices in a choicepoint
must share the same LHS.
Rules of the tributaries of choices in a choicepoint
can have different RHS's, however,
and therefore can differ in symbolic rank.

If all the choices at a choicepoint have the same rank,
we say that the choicepoint is B<trivial>.
We have just seen that the choices of a scanned choicepoint will all have
the same rank,
so that every scanned choicepoint must be trivial.
It follows that every non-trivial choicepoint
will be a reduction.

=head1 Ambiguous choicepoints

If there is only one choice at a choicepoint,
we say that the choicepoint is a B<singleton choicepoint>.
Every singleton choicepoint is trivial,
but some trivial choicepoints are not singletons.

A choicepoint is B<ambiguous> if and only if
it is not a singleton.
All non-trival choicepoints are ambiguous,
but some trivial choicepoints are also ambiguous.
This is because choices at choicepoints may differ not just symbolically,
but in the way in which the symbols divide up the input
string -- the way in which they "factor" the input.
Choices which have the same symbols,
but which are factored differently,
will have the same rank.
For more about symbolic choices (also called B<symches>)
and factorings, see
L<Marpa::R2::Glade/"Ambiguity: factoring versus symches">.

As we have noted,
a scanned choicepoint is never non-trivial,
but a scanned choicepoint may be ambigous if variable length tokens are in use.
Usually variable length tokens are not in use,
and all scanned choicepoint are both trivial and singletons.

A reduction choicepoint may be both non-trivial and ambiguous.
If a reduction choicepoint is non-trivial,
it must differ symbolically from the other choices of that choicepoint.
The mainstem and predot symbol of all the choices in a choicepoint are always
identical, so that if the choices in a reduction choicepoint differ symbolically,
the tributaries of the reduction choices must have different rules.
The predot symbol of a reduction choice is always the LHS of the rule
of its tributary,
so that if two reduction choices differ symbolically,
they must be for two distinct rules which share the same LHS.

=head1 Iterating the parses

Iteration of the parse forest is depth-first, left-to-right.
Choices are ordered from major to minor

=over 4

=item *

by symbolic rank; and

=item *

if null-ranking has been selected,
by the appropriate null-ranking.

=back

The order of two choices is arbitary if they
have same symbolic rank and

=over 4

=item *

null ranking has not been selected or

=item *

their null ranking is the same.

=back

The preceding part of this section contains all most users will need to know
about the iteration algorithm.
The rest of this section describes the iteration algorithm in
detail.

Every node of a parse tree corresponds to a choice
from a choicepoint of the parse forest.
An B<initial parse subtree> is the subtree formed from
an choicepoint-rooted subforest by taking all the first choices of its choicepoints.

The B<initial parse tree> is the initial parse subtree formed
from the subforest whose root in the root of the forest.
In other words, the initial parse tree is the tree formed
by taking the first choices of the entire forest.

The first parse tree in the iterator of a parse forest
is the initial parse tree.

For the second and later parse trees, the next parse tree
is found by traversing the current parse tree from the
bottom up, left to right.
Every node of the parse tree will correspond to a choicepoint
of the parse forest, and a choice within that choicepoint.
If the current choice of its choicepoint is the last choice
of that choicepoint,
we say that that node of the parse tree is B<exhausted>.
If a parse tree node is not B<exhausted>,
we say that is B<active>.

As the traversal of the parse tree encounters
exhausted nodes, it prunes them from the tree.
The traversal ends when it encounters an active parse
tree node.
We call that active parse tree the B<iteration parse tree node>.

Once the iteration parse tree node has been found,
it is replaced with a new tree node
which corresponds to the next choice of the choicepoint
of the iteration parse tree node.

The remaining tree will have missing subtrees due to the replacement
of the iteration parse tree node,
and to the pruning of exhausted nodes.
These subtrees are replaced with initial parse subtrees.

When the entire parse tree is traversed without finding
an active parse tree node,
there are no more parse trees.
In that case,
the parse forest iterator is said to be B<exhausted>.

=head1 Motivation

We note that ranking is only by B<direct> tributaries.
It might reasonably be asked,
why not, at least in the case of a tie,
look at tributaries of tributaries?
Or why not resolve ties by looking at tributaries of
mainstems?

Marpa's built-in rule ranking
was chosen as the most powerful system
that could be implemented with effectively
zero cost.
Ranking by direct tributaries uses only information
that is quickly and directly available,
so that its runtime cost is probably
not measurable.

The complexity of the specification was also an issue.
If indirect tributaries are taken into account,
we would need to specify which tributaries,
and under what circumstances they are used.
Only tributaries of tributaries?
Or tributaries of mainstems?
Depth-first, or breadth-first?
Only in case of ties, or using a more complex metric?
To arbitrary depth, or using a traversal that is
cut off at some point?

If we do ranking by direct tributaries only,
that make the answers
to the above questions as simple as it can be.
Once we get into analyzing the synopsis grammar in detail,
the importance having a specification that is
(relatively) simple will become clear.

To be sure,
there are apps
whose requirements justify extra overhand and extra
complexity.
For these apps,
L<Marpa's ASF's|Marpa::R2::ASF>
allow full generality in ranking.

=head1 Examples

Our examples in this document will look at
the ranked grammar in the synopsis,
and at variations of it.

=head2 Longest highest, version 1

The DSL in the synopsis ranks its items
"longest highest".
Here "items" are represented by the symbols,
C<< <Item3> >>,
C<< <Item2> >> and
C<< <Item1> >>.
The "longest" choice is considered to be the one
with the most lexemes.
Working this idea out for this grammar,
we see that the items
should rank,
from highest to lowest:
C<< <Item3> >>,
C<< <Item2> >> and
C<< <Item1> >>.

=for Marpa::R2::Display
name: Rank document synopsis
normalize-whitespace: 1
partial: 1

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array

  Top ::= List action => main::group
  List ::= Item3 rank => 3
  List ::= Item2 rank => 2
  List ::= Item1 rank => 1
  List ::= List Item3 rank => 3
  List ::= List Item2 rank => 2
  List ::= List Item1 rank => 1
  Item3 ::= VAR '=' VAR action => main::concat
  Item2 ::= VAR '='     action => main::concat
  Item1 ::= VAR         action => main::concat
  VAR ~ [\w]+

=for Marpa::R2::Display::End

=head2 Shortest highest, version 1

Here we see the grammar of the synopsis,
reworked for a "shortest highest"
ranking.
"Shortest highest" is the reverse of
"longest highest".

=for Marpa::R2::Display
name: Ranking, shortest highest, version 1

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array

  Top ::= List action => main::group
  List ::= Item3 rank => 1
  List ::= Item2 rank => 2
  List ::= Item1 rank => 3
  List ::= List Item3 rank => 1
  List ::= List Item2 rank => 2
  List ::= List Item1 rank => 3
  Item3 ::= VAR '=' VAR action => main::concat
  Item2 ::= VAR '='     action => main::concat
  Item1 ::= VAR         action => main::concat
  VAR ~ [\w]+

=for Marpa::R2::Display::End

Here are what the results will look like for
"shortest highest".

=for Marpa::R2::Display
name: Ranking results, shortest highest, version 1

    my @tests = (
        [ 'a',                 '(a)', ],
        [ 'a = b',             '(a=)(b)', ],
        [ 'a = b = c',         '(a=)(b=)(c)', ],
        [ 'a = b = c = d',     '(a=)(b=)(c=)(d)', ],
        [ 'a = b c = d',       '(a=)(b)(c=)(d)' ],
        [ 'a = b c = d e =',   '(a=)(b)(c=)(d)(e=)' ],
        [ 'a = b c = d e',     '(a=)(b)(c=)(d)(e)' ],
        [ 'a = b c = d e = f', '(a=)(b)(c=)(d)(e=)(f)' ],
    );

=for Marpa::R2::Display::End

=head2 Longest highest, version 2

The previous examples have shown the rule involved
in parse ranking in "spelled out" form.
In fact, a more compact form of the grammar can be used,
as shown below for
"longest highest" ranking.

=for Marpa::R2::Display
name: Ranking, longest highest, version 2

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array

  Top ::= List action => main::group
  List ::= Item rank => 1
  List ::= List Item rank => 0
  Item ::= VAR '=' VAR rank => 3 action => main::concat
  Item ::= VAR '='     rank => 2 action => main::concat
  Item ::= VAR         rank => 1 action => main::concat
  VAR ~ [\w]+

=for Marpa::R2::Display::End

=head2 Shortest highest, version 2

This is the grammar for "shortest highest",
in compact form:

=for Marpa::R2::Display
name: Ranking, shortest highest, version 2

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array

  Top ::= List action => main::group
  List ::= Item rank => 0
  List ::= List Item rank => 1
  Item ::= VAR '=' VAR rank => 1 action => main::concat
  Item ::= VAR '='     rank => 2 action => main::concat
  Item ::= VAR         rank => 3 action => main::concat
  VAR ~ [\w]+

=for Marpa::R2::Display::End

=head1 Reimplementing ranking as pure BNF

It is generally better
to write a grammar as "pure BNF", instead of using ranking.
The advantage of using pure BNF is that you can more readily determine
exactly what language it is that you are parsing:
Ranked grammars make look easier to analyze at first glance,
but the more you look at them the more tricky you
realize they are.

The pure BNF reimplementations below rely on an observation:
The parse string becomes easier to analyze
when we think in terms of fenceposts,
rather than in term of the location of the lexemes.
Fencepost are either initial, final or medial.
The B<initial fencepost> is the position before the first lexeme.
The B<final fencepost> is the position after the last lexeme.
A B<medial fencepost> is the position between two lexemes.
We can call a fencepost a B<VAR-bound>
if it is a either an initial fencepost,
a final fencepost,
or a medial fencepost
that occurs between two C<< <VAR> >> lexemes.
We can then visualize the input string
as a sequence of "VAR-bounded"
substrings.

=head3 Longest highest as pure BNF

Here is the "longest highest" example,
reimplemented as BNF:

=for Marpa::R2::Display
name: Ranking via BNF, longest highest, version 3
normalize-whitespace: 1

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array

  Top            ::= Max_Boundeds action => main::group
  Top            ::= Max_Boundeds Unbounded action => main::group
  Top            ::= Unbounded action => main::group
  Max_Boundeds   ::= Max_Bounded+
  Max_Bounded    ::= Eq_Finals Var_Final3
  Max_Bounded    ::= Var_Final
  Unbounded      ::= Eq_Finals
  Eq_Finals      ::= Eq_Final+
  Var_Final      ::= Var_Final3 | Var_Final1
  Var_Final3     ::= VAR '=' VAR action => main::concat
  Eq_Final       ::= VAR '='     action => main::concat
  Var_Final1     ::= VAR         action => main::concat
  VAR ~ [\w]+

=for Marpa::R2::Display::End

=head3 Shortest highest as pure BNF

We can also reimplement the "shortest highest"
example as BNF.
One of the advantages of a BNF (re)implementation,
is that it often clarifies the grammar.
For example
in this case, we note that
the DSL rule

=for Marpa::R2::Display
name: Ranking via BNF, longest highest, version 3
normalize-whitespace: 1
partial: 1

  Var_Final3     ::= VAR '=' VAR action => main::concat

=for Marpa::R2::Display::End

is, in fact, never used.
We therefore omit it:

=for Marpa::R2::Display
name: Ranking via BNF, shortest highest, version 3
normalize-whitespace: 1

  :discard ~ ws; ws ~ [\s]+
  :default ::= action => ::array

  Top            ::= Max_Boundeds action => main::group
  Top            ::= Max_Boundeds Unbounded action => main::group
  Top            ::= Unbounded action => main::group
  Max_Boundeds   ::= Max_Bounded+
  Max_Bounded    ::= Eq_Finals Var_Final
  Max_Bounded    ::= Var_Final
  Unbounded      ::= Eq_Finals
  Eq_Finals      ::= Eq_Final+
  Eq_Final       ::= VAR '='     action => main::concat
  Var_Final      ::= VAR         action => main::concat
  VAR ~ [\w]+

=for Marpa::R2::Display::End

=head1 Copyright and License

=for Marpa::R2::Display
ignore: 1

  Copyright 2022 Jeffrey Kegler
  This file is part of Marpa::R2.  Marpa::R2 is free software: you can
  redistribute it and/or modify it under the terms of the GNU Lesser
  General Public License as published by the Free Software Foundation,
  either version 3 of the License, or (at your option) any later version.

  Marpa::R2 is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser
  General Public License along with Marpa::R2.  If not, see
  http://www.gnu.org/licenses/.

=for Marpa::R2::Display::End

=cut

# vim: expandtab shiftwidth=4:
